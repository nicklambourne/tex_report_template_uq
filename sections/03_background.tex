\section{Background} \label{sec:bg}
% Briefly summarise key aspects of essential technology used in the project, for the non-expert reader. For example, you should give a brief introduction into SDN, OpenFlow, etc. 

\subsection{SDN}
Software-Defined-Networks (SDN) are a dynamic approach to managing network infrastructure and traffic. In contrast to traditional networking approaches, they separate the data plane and control plane, shifting management responsibilities to a logically centralized controller. The SDN allows the network to be easily programmable, making it easy to iterate and upgrade, and can confer performance advantages in some contexts \cite{SDN}.

SDN are designed around integration with various protocols, designed for communication with network applications (northbound) or with the underlying network hardware (southbound). OpenFlow, discussed further below, is an example of a southbound protocol.

\subsubsection{ONOS}

The Open Network Operating System (ONOS), is an open source SDN controller used by network application developers and commercial operators (e.g. data centre providers, telecommunications networks). ONOS is highly configurable and consists of a number of developer-facing APIs that can be used to create ancillary network applications \cite{ONOS}. \\

The ONOS platform provides:
\begin{itemize}
    \item An extensible, modular, distributed SDN controller and a platform for its extension.
    \item Simplified management, configuration and deployment of new software, hardware and services.
    \item Resiliency and scalability. \cite{ONOS}
\end{itemize} 

Figure \ref{fig:onos} shows the interaction between developer-provided applications and the core ONOS controller (including the intermediate northbound and southbound protocols).

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{project/proposal/img/onos.png}
    \caption{The Interaction Between ONOS Components \cite{onosAPI}}
    \label{fig:onos}
\end{figure}

\subsection{OpenFlow}
OpenFlow is one of the earliest protocols associated with the SDN movement. A southbound interface, it enables the network controller to decide the route of a package across the switches. It allows the controller to operate on switches, including adding, removing and modifying the match rules and actions in order to affect the route packages take though the network. The rules and actions can have adjustable lifespan that can be flexibly planned by the controller \cite{OpenFlow}. 
When a packet arrives a switch, if it can be matched with a rule, that rule will determine what action the switch takes on the packet (e.g. forwarding, flooding or dropping the packet); otherwise, it will be sent to the controller and the controller will respond with a new matched rule and action to tell the switch what to do \cite{OpenFlow}.

\subsection{Load-Balancers}

The transmission of data using TCP/IP and UDP/IP protocols makes up most of the network traffic in a web application context. The total combined data flow in any particular context is referred to as the network load. A longstanding practice in dealing with high overall network load is run multiple replicas of the underlying application server and distribute load between them. However, if load is unbalanced between replicas this may result in higher latency or even network collapse \cite{LoadBalancer}.

A load-balancer acts as traffic controller responsible for distributing the network load in the most efficient way possible (within its own limits and that of the network). The load balancer sits in front of server replicas, and re-orient the incoming data flows to accordingly servers as necessary based on some algorithm or heuristic. \cite{loadBalancingAlgorithms}

The concrete form that a load balancer takes can be either as dedicated hardware or as dedicated software running on generic underlying hardware, each of which has advantages and disadvantages. A hardware solution typically has much better performance but also suffers from much higher cost. Comparatively, the software load balancer typically isn't as performant as hardware, but is much cheaper, as well as well as being easier to install and configure.

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{project/proposal/img/load balancer disgram.jpg}
    \caption{The Load Balancer Environment \cite{nginxPlus}}
    \label{fig:my_label}
\end{figure}

\subsection{Grafana k6}

Grafana k6 is a network load testing tool that provides a simple and configurable interface for producing simulated HTTP traffic and is commonly used in various load-testing contexts. Out of the box it provides a plethora of useful statistics, like latency (to arbitrary percentiles) and throughput, that can be used to assess network and server performance.\cite{k6} Figure \ref{fig:k6} shows the standard k6 summary report.

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{project/proposal/img/output_k6.jpg}
    \caption{Standard Output of k6}
    \label{fig:k6}
\end{figure}

\subsection{Load Balancing Algorithms}

Load balancing is typically more nuanced than simply sending an equal number of packets to each application server. This added complexity is typically shouldered by a ``load-balancing algorithm". There exist dozens of commonly used algorithms, each with multiple sub-variants \cite{loadBalancingAlgorithms}. Some of the more common algorithms and details of their operation are described below.

\begin{itemize}
    \item Round Robin
    
    As the name Round Robin suggests, the algorithm forwards incoming requests to available servers sequentially, it means a server will not be assigned the next request unless all the other servers have been assigned a request. It is amongst the simplest of load-balancing algorithms and is also straightforward to implement. The limitation of this kind of algorithm is that it can only perform well if all servers share similar performance characteristics, while in reality this is often not always the case, and many other factors need to be considered.\cite{PerformanceAnalysis1}
    
    \item Weighted Round Robin 
    
    This algorithm is a variant of the regular Round Robin with an added factor called weight. A weight value is assigned for every server according to its capacity to handle the requests from clients, and it arranges incoming requests based on the weights. The higher the weight of a server, the higher the probability of being assigned the next task. This new attribute makes the algorithm more flexible, for instance with the addition of a new server, and the weights can be modified as needed. \cite{WeightedRoundRobin}.
    
    \item Resource Based (Adaptive) 
    
    Based on Weighted Round Robin but with the added feature that agents can report the current load to the controller and this is used in the allocation decision-making process. This mechanism whereby the load balancer knows the instantaneous loads of all the servers allows it to calculate up-to-date weight values and arrange incoming requests based on those results. The added flexibility and reactivity typically results in higher performance. \cite{LoadBalancingAlgorithms2}
    
    \item Source IP Hash
    
    In this algorithm, every single server will only receive the requests with certain hash values, binding each client to a particular server so that the requests from the client will all be forwarded to that server \cite{kemp_2022}. This method allows for client re-connection with the same application server, but given that these applications are usually designed to be stateless and there is no quantitative performance implication it is expected that this algorithm would demonstrate similar performance to Round Robin on average.
    
    \item Least Connection
    
    This kind of algorithm arranges the incoming requests according to the current number of connections to each of the servers, it always arrange the next request to that server with the least connections. It assume that servers both have the similar capacities, so the performance may be impacted if the capacities are not in balanced distribution\cite{loadBalancingAlgorithms}. It does not consider the prospective size or processing time of each request, so may still not reach an optimal distribution. 
    
\end{itemize}

\subsection{Mininet}

Mininet is an application providing a virtual environment for testing networks, including SDNs, on a single computer. It can simulate a real network's controllers, switches, and hosts. It offers both a command line interface and a Python-based API for more complex use cases. \cite{Mininet}.

Figure \ref{fig:mn} shows the command line interface after having created two virtual hosts, one virtual switch, and a controller.

%\url{https://groups.google.com/a/onosproject.org/g/onos-discuss/c/51OeI8LaUF4}
%\url{https://github.com/opennetworkinglab/onos/blob/master/apps/mlb/src/main/java/org/onosproject/mlb/MastershipLoadBalancer.java}

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{project/proposal/img/mn.png}
    \caption{The Mininet Command Line Interface}
    \label{fig:mn}
\end{figure}